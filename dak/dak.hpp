/*
 * Dimensional Analysis Kit
 *
 * Copyright snsnf 2017.
 * Distributed under the Boost Software License, Version 1.0.
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef INCLUDED_DAK_HPP
#define INCLUDED_DAK_HPP

#include <cmath>

namespace dak
{
    //----------------------------------------------------------------
    // Traits
    //----------------------------------------------------------------

    template<typename D>
    struct dimension_traits;

    template<typename D1, typename D2>
    struct product_dimension;

    template<typename D1, typename D2>
    struct quotient_dimension;

    template<typename D, int N>
    struct power_dimension;

    template<typename D, int N>
    struct root_dimension;

    template<typename D1, typename D2>
    using product_dimension_t = typename product_dimension<D1, D2>::type;

    template<typename D1, typename D2>
    using quotient_dimension_t = typename quotient_dimension<D1, D2>::type;

    template<typename D, int N>
    using power_dimension_t = typename power_dimension<D, N>::type;

    template<typename D, int N>
    using root_dimension_t = typename root_dimension<D, N>::type;

    //----------------------------------------------------------------
    // Scalar quantity with dimensional analysis
    //----------------------------------------------------------------

    namespace detail // for dak::scalar
    {
        // This class mixes in (1) member variable value_ and (2) proper
        // constructors and convertion operator.
        template<typename T, typename D, bool AllowConversion = dimension_traits<D>::is_zero>
        class scalar_mixin;

        template<typename T, typename D>
        class scalar_mixin<T, D, false>
        {
          public:
            scalar_mixin() = default;

            explicit scalar_mixin(T value)
                : value_{value}
            {
            }

          protected:
            T value_{};
        };

        template<typename T, typename D>
        class scalar_mixin<T, D, true>
        {
          public:
            scalar_mixin() = default;

            scalar_mixin(T value) // NOLINT
                : value_{value}
            {
            }

            operator T() const // NOLINT
            {
                return value_;
            }

          protected:
            T value_{};
        };
    } // namespace detail

    /*
     * Scalar quantity with dimensional analysis.
     */
    template<typename T, typename D>
    class scalar : public detail::scalar_mixin<T, D>
    {
        using scalar_mixin = detail::scalar_mixin<T, D>;
        using scalar_mixin::value_;

      public:
        using number_type = T;
        using dimension = D;
        using scalar_mixin::scalar_mixin;

        number_type value() const
        {
            return value_;
        }

        scalar& operator+=(scalar const& rhs)
        {
            value_ += rhs.value_;
            return *this;
        }

        scalar& operator-=(scalar const& rhs)
        {
            value_ -= rhs.value_;
            return *this;
        }

        scalar& operator*=(number_type scale)
        {
            value_ *= scale;
            return *this;
        }

        scalar& operator/=(number_type scale)
        {
            value_ /= scale;
            return *this;
        }
    };

    template<typename T, typename D>
    bool operator==(scalar<T, D> const& x, scalar<T, D> const& y)
    {
        return x.value() == y.value();
    }

    template<typename T, typename D>
    bool operator!=(scalar<T, D> const& x, scalar<T, D> const& y)
    {
        return !(x == y);
    }

    template<typename T, typename D>
    bool operator<(scalar<T, D> const& x, scalar<T, D> const& y)
    {
        return x.value() < y.value();
    }

    template<typename T, typename D>
    bool operator>(scalar<T, D> const& x, scalar<T, D> const& y)
    {
        return x.value() > y.value();
    }

    template<typename T, typename D>
    bool operator<=(scalar<T, D> const& x, scalar<T, D> const& y)
    {
        return x.value() <= y.value();
    }

    template<typename T, typename D>
    bool operator>=(scalar<T, D> const& x, scalar<T, D> const& y)
    {
        return x.value() >= y.value();
    }

    template<typename T, typename D>
    scalar<T, D> operator+(scalar<T, D> const& x)
    {
        return x;
    }

    template<typename T, typename D>
    scalar<T, D> operator-(scalar<T, D> const& x)
    {
        return scalar<T, D>{-x.value()};
    }

    template<typename T, typename D>
    scalar<T, D> operator+(scalar<T, D> const& x, scalar<T, D> const& y)
    {
        return scalar<T, D>{x} += y;
    }

    template<typename T, typename D>
    scalar<T, D> operator-(scalar<T, D> const& x, scalar<T, D> const& y)
    {
        return scalar<T, D>{x} -= y;
    }

    template<typename T, typename D>
    scalar<T, D> operator*(scalar<T, D> const& x, typename scalar<T, D>::number_type y)
    {
        return scalar<T, D>{x} *= y;
    }

    template<typename T, typename D>
    scalar<T, D> operator*(typename scalar<T, D>::number_type x, scalar<T, D> const& y)
    {
        return scalar<T, D>{y} *= x;
    }

    template<typename T, typename D>
    scalar<T, D> operator/(scalar<T, D> const& x, typename scalar<T, D>::number_type y)
    {
        return scalar<T, D>{x} /= y;
    }

    template<typename T, typename D, typename RD = power_dimension_t<D, -1>>
    scalar<T, RD> operator/(typename scalar<T, D>::number_type x, scalar<T, D> const& y)
    {
        return scalar<T, RD>{x / y.value()};
    }

    template<typename T, typename DX, typename DY, typename RD = product_dimension_t<DX, DY>>
    scalar<T, RD> operator*(scalar<T, DX> const& x, scalar<T, DY> const& y)
    {
        return scalar<T, RD>{x.value() * y.value()};
    }

    template<typename T, typename DX, typename DY, typename RD = quotient_dimension_t<DX, DY>>
    scalar<T, RD> operator/(scalar<T, DX> const& x, scalar<T, DY> const& y)
    {
        return scalar<T, RD>{x.value() / y.value()};
    }

    template<typename T, typename D>
    scalar<T, D> abs(scalar<T, D> const& x)
    {
        return scalar<T, D>{std::fabs(x.value())};
    }

    template<typename T, typename D>
    scalar<T, D> hypot(scalar<T, D> const& x, scalar<T, D> const& y)
    {
        return scalar<T, D>{std::hypot(x.value(), y.value())};
    }

    template<int N, typename T, typename D, typename RD = power_dimension_t<D, N>>
    scalar<T, RD> pow(scalar<T, D> const& x)
    {
        return scalar<T, RD>{std::pow(x.value(), N)};
    }

    template<typename T, typename D, typename RD = root_dimension_t<D, 2>>
    scalar<T, RD> sqrt(scalar<T, D> const& x)
    {
        return scalar<T, RD>{std::sqrt(x.value())};
    }

    template<typename T, typename D, typename RD = root_dimension_t<D, 3>>
    scalar<T, RD> cbrt(scalar<T, D> const& x)
    {
        return scalar<T, RD>{std::cbrt(x.value())};
    }

    //----------------------------------------------------------------
    // Vector quantity with dimensional analysis
    //----------------------------------------------------------------

    namespace detail // for dak::vector
    {
        // Dummy class for passing around type parameter packs. This is used to
        // pack generated parameter types of coords_mixin's constructors.
        template<typename...>
        struct type_sequence
        {
        };

        // Creates type_sequence of T repeated N times.
        template<typename T, unsigned N, typename... Seq>
        struct repeat_type
        {
            using type = typename repeat_type<T, N - 1, T, Seq...>::type;
        };

        template<typename T, typename... Seq>
        struct repeat_type<T, 0, Seq...>
        {
            using type = type_sequence<Seq...>;
        };

        // This class mixes in (1) member variable coords_ and (2) proper
        // constructors.
        template<typename T, typename D, unsigned N, typename = typename repeat_type<T, N>::type>
        class coords_mixin;

        template<typename T, typename D, unsigned N, typename... Ts>
        class coords_mixin<T, D, N, type_sequence<Ts...>>
        {
          public:
            coords_mixin() = default;

            explicit coords_mixin(Ts... coords)
                : coords_{scalar<Ts, D>{coords}...}
            {
            }

            coords_mixin(scalar<Ts, D>... coords) // NOLINT
                : coords_{coords...}
            {
            }

          protected:
            scalar<T, D> coords_[N]{};
        };
    } // namespace detail

    /*
     * Vector with dimensional analysis.
     */
    template<typename T, typename D, unsigned N>
    class vector : private detail::coords_mixin<T, D, N>
    {
        using coords_mixin = detail::coords_mixin<T, D, N>;
        using coords_mixin::coords_;

      public:
        using number_type = T;
        using scalar_type = scalar<T, D>;
        static constexpr unsigned dimension = N;

        using coords_mixin::coords_mixin;

        scalar_type& operator[](unsigned index)
        {
            return coords_[index];
        }

        scalar_type const& operator[](unsigned index) const
        {
            return coords_[index];
        }

        vector& operator+=(vector const& rhs)
        {
            for (unsigned i = 0; i < dimension; ++i) {
                coords_[i] += rhs.coords_[i];
            }
            return *this;
        }

        vector& operator-=(vector const& rhs)
        {
            for (unsigned i = 0; i < dimension; ++i) {
                coords_[i] -= rhs.coords_[i];
            }
            return *this;
        }

        vector& operator*=(number_type scale)
        {
            for (unsigned i = 0; i < dimension; ++i) {
                coords_[i] *= scale;
            }
            return *this;
        }

        vector& operator/=(number_type scale)
        {
            for (unsigned i = 0; i < dimension; ++i) {
                coords_[i] /= scale;
            }
            return *this;
        }
    };

    template<typename T, typename D, unsigned N>
    bool operator==(vector<T, D, N> const& v, vector<T, D, N> const& w)
    {
        for (unsigned i = 0; i < N; ++i) {
            if (v[i] != w[i]) {
                return false;
            }
        }
        return true;
    }

    template<typename T, typename D, unsigned N>
    bool operator!=(vector<T, D, N> const& v, vector<T, D, N> const& w)
    {
        return !(v == w);
    }

    template<typename T, typename D, unsigned N>
    vector<T, D, N> operator+(vector<T, D, N> const& v)
    {
        return v;
    }

    template<typename T, typename D, unsigned N>
    vector<T, D, N> operator-(vector<T, D, N> const& v)
    {
        vector<T, D, N> result;
        for (unsigned i = 0; i < N; ++i) {
            result[i] = -v[i];
        }
        return result;
    }

    template<typename T, typename D, unsigned N>
    vector<T, D, N> operator+(vector<T, D, N> const& v, vector<T, D, N> const& w)
    {
        return vector<T, D, N>(v) += w;
    }

    template<typename T, typename D, unsigned N>
    vector<T, D, N> operator-(vector<T, D, N> const& v, vector<T, D, N> const& w)
    {
        return vector<T, D, N>(v) -= w;
    }

    template<typename T, typename D, unsigned N>
    vector<T, D, N> operator*(vector<T, D, N> const& v, typename vector<T, D, N>::number_type a)
    {
        return vector<T, D, N>(v) *= a;
    }

    template<typename T, typename D, unsigned N>
    vector<T, D, N> operator*(typename vector<T, D, N>::number_type a, vector<T, D, N> const& v)
    {
        return vector<T, D, N>(v) *= a;
    }

    template<typename T, typename D, unsigned N>
    vector<T, D, N> operator/(vector<T, D, N> const& v, typename vector<T, D, N>::number_type a)
    {
        return vector<T, D, N>(v) /= a;
    }

    template<typename T, typename D1, typename D2, unsigned N,
        typename RD = product_dimension_t<D1, D2>>
    vector<T, RD, N> operator*(vector<T, D1, N> const& v, scalar<T, D2> const& a)
    {
        vector<T, RD, N> result;
        for (unsigned i = 0; i < N; ++i) {
            result[i] = v[i] * a;
        }
        return result;
    }

    template<typename T, typename D1, typename D2, unsigned N,
        typename RD = product_dimension_t<D1, D2>>
    vector<T, RD, N> operator*(scalar<T, D1> const& a, vector<T, D2, N> const& v)
    {
        vector<T, RD, N> result;
        for (unsigned i = 0; i < N; ++i) {
            result[i] = a * v[i];
        }
        return result;
    }

    template<typename T, typename D1, typename D2, unsigned N,
        typename RD = quotient_dimension_t<D1, D2>>
    vector<T, RD, N> operator/(vector<T, D1, N> const& v, scalar<T, D2> const& a)
    {
        vector<T, RD, N> result;
        for (unsigned i = 0; i < N; ++i) {
            result[i] = v[i] / a;
        }
        return result;
    }

    template<typename T, typename D1, typename D2, unsigned N,
        typename RD = product_dimension_t<D1, D2>>
    scalar<T, RD> dot(vector<T, D1, N> const& v, vector<T, D2, N> const& w)
    {
        scalar<T, RD> result{0};
        for (unsigned i = 0; i < N; ++i) {
            result += v[i] * w[i];
        }
        return result;
    }

    template<typename T, typename D, unsigned N, typename RD = power_dimension_t<D, 2>>
    scalar<T, RD> squared_norm(vector<T, D, N> const& v)
    {
        return dot(v, v);
    }

    template<typename T, typename D, unsigned N>
    scalar<T, D> norm(vector<T, D, N> const& v)
    {
        return sqrt(squared_norm(v));
    }

    template<typename T, typename D1, typename D2, typename RD = product_dimension_t<D1, D2>>
    vector<T, RD, 3> cross(vector<T, D1, 3> const& v, vector<T, D2, 3> const& w)
    {
        auto const x = v[1] * w[2] - v[2] * w[1];
        auto const y = v[2] * w[0] - v[0] * w[2];
        auto const z = v[0] * w[1] - v[1] * w[0];
        return vector<T, RD, 3>{x, y, z};
    }

    //----------------------------------------------------------------
    // Cartesian point with dimensional analysis
    //----------------------------------------------------------------

    /*
     * Cartesian point with dimensional analysis.
     */
    template<typename T, typename D, unsigned N>
    class point : private detail::coords_mixin<T, D, N>
    {
        using coords_mixin = detail::coords_mixin<T, D, N>;
        using coords_mixin::coords_;

      public:
        using number_type = T;
        using scalar_type = scalar<T, D>;
        using vector_type = vector<T, D, N>;
        static constexpr unsigned dimension = N;

        using coords_mixin::coords_mixin;

        scalar_type& operator[](unsigned index)
        {
            return coords_[index];
        }

        scalar_type const& operator[](unsigned index) const
        {
            return coords_[index];
        }

        point& operator+=(vector_type const& rhs)
        {
            for (unsigned i = 0; i < dimension; ++i) {
                coords_[i] += rhs[i];
            }
            return *this;
        }

        point& operator-=(vector_type const& rhs)
        {
            for (unsigned i = 0; i < dimension; ++i) {
                coords_[i] -= rhs[i];
            }
            return *this;
        }
    };

    template<typename T, typename D, unsigned N>
    bool operator==(point<T, D, N> const& v, point<T, D, N> const& w)
    {
        for (unsigned i = 0; i < N; ++i) {
            if (v[i] != w[i]) {
                return false;
            }
        }
        return true;
    }

    template<typename T, typename D, unsigned N>
    bool operator!=(point<T, D, N> const& v, point<T, D, N> const& w)
    {
        return !(v == w);
    }

    template<typename T, typename D, unsigned N>
    point<T, D, N> operator+(point<T, D, N> const& p, vector<T, D, N> const& v)
    {
        return point<T, D, N>{p} += v;
    }

    template<typename T, typename D, unsigned N>
    vector<T, D, N> operator-(point<T, D, N> const& p, point<T, D, N> const& q)
    {
        vector<T, D, N> result;
        for (unsigned i = 0; i < N; ++i) {
            result[i] = p[i] - q[i];
        }
        return result;
    }

    template<typename T, typename D, unsigned N, typename RD = power_dimension_t<D, 2>>
    scalar<T, RD> squared_distance(point<T, D, N> const& p, point<T, D, N> const& q)
    {
        return squared_norm(p - q);
    }

    template<typename T, typename D, unsigned N>
    scalar<T, D> distance(point<T, D, N> const& p, point<T, D, N> const& q)
    {
        return norm(p - q);
    }

    //----------------------------------------------------------------
    // Reference dimension implementation
    //----------------------------------------------------------------

    template<int L, int M, int T>
    struct mechanical_dimension
    {
    };

    template<int L, int M, int T>
    struct dimension_traits<mechanical_dimension<L, M, T>>
    {
        static constexpr bool is_zero = (L == 0 && M == 0 && T == 0);
    };

    template<int L1, int M1, int T1, int L2, int M2, int T2>
    struct product_dimension<mechanical_dimension<L1, M1, T1>, mechanical_dimension<L2, M2, T2>>
    {
        using type = mechanical_dimension<L1 + L2, M1 + M2, T1 + T2>;
    };

    template<int L1, int M1, int T1, int L2, int M2, int T2>
    struct quotient_dimension<mechanical_dimension<L1, M1, T1>, mechanical_dimension<L2, M2, T2>>
    {
        using type = mechanical_dimension<L1 - L2, M1 - M2, T1 - T2>;
    };

    template<int L, int M, int T, int N>
    struct power_dimension<mechanical_dimension<L, M, T>, N>
    {
        using type = mechanical_dimension<L * N, M * N, T * N>;
    };

    template<int L, int M, int T, int N>
    struct root_dimension<mechanical_dimension<L, M, T>, N>
    {
        static_assert(
            L % N == 0 && M % N == 0 && T % N == 0, "fractional dimension is not supported");
        using type = mechanical_dimension<L / N, M / N, T / N>;
    };

    namespace dim
    {
        using number = mechanical_dimension<0, 0, 0>;
        using length = mechanical_dimension<1, 0, 0>;
        using mass = mechanical_dimension<0, 1, 0>;
        using time = mechanical_dimension<0, 0, 1>;
        using speed = quotient_dimension_t<length, time>;
        using acceleration = quotient_dimension_t<speed, time>;
        using momentum = product_dimension_t<speed, mass>;
        using force = product_dimension_t<acceleration, mass>;
        using energy = product_dimension_t<force, length>;
    } // namespace dim
} // namespace dak

#endif // INCLUDED_DAK_HPP
